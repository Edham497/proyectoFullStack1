let express,User,bcrypt,NOT_FOUND,AUTH_REJECTED,DUPLICATED,SERVER_ERROR;_3c0‍.x([["default",()=>_3c0‍.o]]);_3c0‍.w("express",[["default",["express"],function(v){express=v}]]);_3c0‍.w("../models/user",[["default",["User"],function(v){User=v}]]);_3c0‍.w("bcryptjs",[["default",["bcrypt"],function(v){bcrypt=v}]]);_3c0‍.w("../models/errorHandler",[["NOT_FOUND",["NOT_FOUND"],function(v){NOT_FOUND=v}],["AUTH_REJECTED",["AUTH_REJECTED"],function(v){AUTH_REJECTED=v}],["DUPLICATED",["DUPLICATED"],function(v){DUPLICATED=v}],["SERVER_ERROR",["SERVER_ERROR"],function(v){SERVER_ERROR=v}]]);





const router = express.Router()

router.get('/', async (request, response) => {
    try {
        const listaUsuarios = await User.find({})
        if (listaUsuarios.length < 2)
            response.status(200).json(listaUsuarios[0])
        else
            response.status(200).json(listaUsuarios)
    } catch (e) {
        SERVER_ERROR(response)
    }
})

router.post('/find', async(request, response) => {
    try {
        const user = await User.findOne({ email: request.body.email })
        if(user){
            response.status(200).json({
                status: "OK",
                usr_data: {
                    rol: user.rol,
                    nombre: user.nombre,
                    direccion: user.direccion,
                    telefono: user.telefono,
                    email: user.email,
                    createdAt: user.createdAt
                }
            })
        }else{
            response.status(404).json({
                status: "NOT_FOUND",
                error: 'El usuario no existe'
            })
        }
    }catch(e){
        response.status(500).json({
            status: "SERVER_ERROR",
            error: 'Error de servidor',
        })
    }
})

router.post('/add', async (request, response) => {
    try {
        request.body.password = await bcrypt.hash(request.body.password, 10)
        const user = new User(request.body)
        await user.save()
        response.status(201).json({ status: 'OK' })
    } catch (e) {
        if (e.code == 11000) {
            response.status(500).json({
                status: "DUPLICATED",
                error: "Usuario, Correo o Telefono ya existe"
            })
        } else
            response.status(500).json({
                status: "SERVER_ERROR",
                error: 'Error de servidor',
            })
    }
})

router.put('/edit', async (request, response) => {
    const { userToChange, data } = request.body
    const res = await User.updateOne({ email: userToChange }, { $set: data })
    response.status(202).json({ status: 'OK', backlog: JSON.stringify(res) })
})

// router.delete('/delete', async(request, response) => {
//     const useroToDelete = request.body
//     const res = await User.findByIdAndDelete({ _id: request.body._id });
// })

router.post('/login', async (request, response) => {
    try {
        const user = await User.findOne({ email: request.body.email })
        if (user) {
            if (await bcrypt.compare(request.body.password, user.password)) {
                response.status(200).json({
                    status: "OK",
                    usr_data: {
                        rol: user.rol,
                        nombre: user.nombre,
                        direccion: user.direccion,
                        telefono: user.telefono,
                        email: user.email,
                        createdAt: user.createdAt
                    }
                })
            } else {
                response.status(401).json({
                    status: "AUTH_REJECTED",
                    error: 'correo o contraseña incorrectos'
                })
            }
        } else {
            response.status(404).json({
                status: "NOT_FOUND",
                error: 'El usuario no existe'
            })
        }
    } catch (e) {
        _3c0‍.g.console.log(e)
        response.status(500).json({
            status: "SERVER_ERROR",
            error: 'Error de servidor',
        })
    }
})

router.post('/verify', async (request, response) => {
    try {
        const user = await User.findOne({ email: request.body.email })
        if (user) {
            if (await bcrypt.compare(request.body.password, user.password)) {
                response.status(200).json({
                    status: "OK"
                })
            } else {
                response.status(400).json({
                    status: "AUTH_REJECTED",
                    error: 'correo o contraseña incorrectos'
                })
            }
        }
    } catch (e) {
        response.status(500).json({
            status: "SERVER_ERROR",
            error: 'Error de servidor',
        })
    }
})

router.post('/changePassword', async (request, response) => {
    const { userToChange, data } = request.body
    _3c0‍.g.console.log(userToChange, data)
    const newPassword = await bcrypt.hash(data, 10)
    const res = await User.updateOne({ email: userToChange }, { $set: { password: newPassword } })
    response.status(200).json({ status: 'OK' })
})

_3c0‍.d(router);